---
title: 《Redis 设计与实现：事务》
date: 2017-10-05 01:36:01
tags: [Redis, Database]
categories: [读书笔记, Redis]
---
### 1. 事务的实现
一个事务从开始到结束通常会经历以下三个阶段：

- 事务开始。
- 命令入队。
- 事务执行。

<!--more-->

#### 1.1 事务开始
`MULTI` 命令的执行标志着事务的开始：

```
redis> MULTI
OK
```
`MULTI` 命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的 `flags` 属性中打开 `REDIS_MULTI` 标识来完成的，`MULTI` 命令的实现可以用以下伪代码来表示：

```
def MULTI():

    # 打开事务标识
    client.flags |= REDIS_MULTI

    # 返回 OK 回复
    replyOK()
```

### 1.2 命令入队
当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：

- 如果客户端发送的命令为 `EXEC`、 `DISCARD`、 `WATCH`、 `MULTI` 四个命令的其中一个，那么服务器立即执行这个命令。
- 与此相反，如果客户端发送的命令是 `EXEC`、`DISCARD`、`WATCH`、`MULTI` 四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回 `QUEUED` 回复。

### 1.3 事务队列
每个 Redis 客户端都有自己的事务状态，这个事务状态保存在客户端状态的 `mstate` 属性里面：

```c
typedef struct redisClient {

    // ...

    // 事务状态
    multiState mstate;      /* MULTI/EXEC state */

    // ...

} redisClient;
```
事务状态包含一个事务队列，以及一个已入队命令的计数器（也可以说是事务队列的长度）：

```c
typedef struct multiState {

    // 事务队列，FIFO 顺序
    multiCmd *commands;

    // 已入队命令计数
    int count;

} multiState;
```
事务队列是一个 `multiCmd` 类型的数组，数组中的每个 `multiCmd` 结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针，命令的参数，以及参数的数量：

```
typedef struct multiCmd {

    // 参数
    robj **argv;

    // 参数数量
    int argc;

    // 命令指针
    struct redisCommand *cmd;

} multiCmd;
```
事务队列以先进先出（FIFO）的方式保存入队的命令：较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。

### 1.4 执行事务
当一个处于事务状态的客户端向服务器发送 `EXEC` 命令时，这个 `EXEC` 命令将立即被服务器执行： 服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

`EXEC` 命令的实现原理可以用以下伪代码来描述：

```
def EXEC():

    # 创建空白的回复队列
    reply_queue = []

    # 遍历事务队列中的每个项
    # 读取命令的参数，参数的个数，以及要执行的命令
    for argv, argc, cmd in client.mstate.commands:

        # 执行命令，并取得命令的返回值
        reply = execute_command(cmd, argv, argc)

        # 将返回值追加到回复队列末尾
        reply_queue.append(reply)

    # 移除 REDIS_MULTI 标识，让客户端回到非事务状态
    client.flags &= ~REDIS_MULTI

    # 清空客户端的事务状态，包括：
    # 1）清零入队命令计数器
    # 2）释放事务队列
    client.mstate.count = 0
    release_transaction_queue(client.mstate.commands)

    # 将事务的执行结果返回给客户端
    send_reply_to_client(client, reply_queue)
```

### 2. WATCH 命令的实现
`WATCH` 命令是一个乐观锁（optimistic locking），它可以在 `EXEC` 命令执行之前，监视任意数量的数据库键，并在 `EXEC` 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复（nil）。 `WATCH` 命令总是返回 OK。

#### 2.1 使用 WATCH 命令监视数据库键
每个 Redis 数据库都保存着一个 `watched_keys` 字典，这个字典的键是某个被 `WATCH` 命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：

```c
typedef struct redisDb {
    
    // ...
    dict *watched_keys;
  
    // ...
  
} redisDb;
```
通过 `watched_keys` 字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。

通过执行 `WATCH` 命令，客户端可以在 `watched_keys` 字典中与被监视的键进行关联。

### 2.2 监视机制的触发

所有对数据库进行修改的命令，比如 `SET`、`LPUSH`、`SADD`、`ZREM`、`DEL`、`FLUSHDB` 等等，在执行之后都会调用 `multi.c/touchWatchKey` 函数对 `watched_keys` 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么 `touchWatchKey` 函数就会将监视被修改键的客户端的 `REDIS_DIRTY_CAS` 标识打开，表示该客户端的事务安全性已经被破坏。

`touchWatchKey` 函数的定义可以用以下伪代码来描述：

```
def touchWatchKey(db, key):

	# 如果键 key 存在于数据库的 watched_keys 字典中
	# 那么说明至少有一个客户端在监视这个 key
	if key in db.watched_keys:
	
		# 遍历所有监视键 key 的客户端
		for client in db.watched_keys[key]:
		
			# 打开标识
			client.flags |= REDIS_DIRTY_CAS
```

### 2.3 判断事务是否安全

当服务器接收到一个客户端发来的 `EXEC` 命令时，服务器会根据这个客户端是否打开了 `REDIS_DIRTY_CAS` 标识来决定是否执行事务：

- 如果客户端的 `REDIS_DIRTY_CAS` 标识已经被打开，那么说明客户端所监视的键当中，至少有 一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。
- 如果客户端的 `REDIS_DIRTY_CAS` 标识没有被打开，那么说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务。

## 3. 事务的 ACID 性质

在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。

在 Redis 中，事务总是具有原子性（Atomicity）， 一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。

### 3.1 原子性

事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。 

对于 Redis 的事务功能来说，事务队列中的命令要么就全部执行，要么就一个都不执行，因此，Redis 的事务是具有原子性的。

Redis 的事务和传统的关系型数据库事务的最大区别在于，Redis 不支持事务的回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会
继续执行下去，直到将事务队列中的所有命令都执行完毕为止。

### 3.2 一致性

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

”一致“ 指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。

Redis 通过谨慎的错误检测和简单的设计来保证事务一致性。

#### 3.2.1 入队错误 

一个事务在入队命令的过程中，出现了命令不存在或者命令格式不正确等情况，那么 Redis 将拒绝执行这个事务，因此 Redis 事务的一致性不会被带有入队错误的事务影响。

#### 3.2.2 执行错误

因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。

#### 3.2.3 服务器停机

如果 Redis 服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：

- 如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。
- 如果服务器运行在 RDB 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 RDB 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 RDB 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。
- 如果服务器运行在 AOF 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 AOF 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

综上所述，无论 Redis 服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。

### 3.3 隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全 相同。 

因为 Redis 使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事物进行中断，因此，Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。

### 3.4 耐久性

事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保持到永久存储介质（比如硬盘）里面，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。 

因为 Redis 事务不过是简单的用队列包裹起了一组 Redis 命令，Redis 并没有为事务提供任何额外的持久化功能，所以 Redis 事务的耐久性由 Redis 所使用的持久化模式决定： 

- 当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。
- 当服务器在 RDB 持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行 `BGSAVE` 命令，对数据库进行保存操作，并且异步执行的 `BGSAVE` 不能保证事务数据被第一时间保存到硬盘里面，因此 RDB 持久化模式下的事务也不具有耐久性。
- 当服务器运行在 AOF 持久化模式下，并且 `appedfsync` 选项的值为 `always` 时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。 
- 当服务器运行在 AOF 持久化模式下，并且 `appedfsync` 的选项的值为 `everysec` 时，程序会每秒同步一次命令数据到磁盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。
- 当服务器运行在 AOF 持久化模式下，并且 `appedfsync` 的选项的值为 `no` 时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。